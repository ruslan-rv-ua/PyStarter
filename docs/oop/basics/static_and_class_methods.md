---
hide:
#  - navigation # Hide navigation
 - toc        # Hide table of contents
---

# Статичні та класові методи

Згідно [моделі даних](https://docs.python.org/3.6/), 
Python пропонує три види методів: 
статичні, класові і екземпляра класа. 

## Методи екземпляра класа

Це вже знайомий нам вид методів. 
Методи екземпляра класа приймають об'єкт класа як перший аргумент, 
який прийнято називати `self` і який вказує на сам екземпляр. 

Використовуючи параметр `self` ми можемо міняти стан об'єкта і звертатись до інших його методів 
і параметрів. 
Також через атрибут `self.__class__` можна отримати доступ до атрибутів класа 
і можливість міняти стан самого класа. 
Тобто методи екземплярів класа дозволяють міняти як стан певного об'єкта, так і класа. 
	
## Класові методи

Методи класа приймають клас в якості параметра, 
його прийнято позначати як `cls`. 
Він вказує на клас, а не на об'єкт цього класа. 
При декларації методів цього вида використовують наступний синтаксис: 

	>>> class A:
	...     @classmethod
	...     def f(cls):
	...             pass
	...
	>>> A.f
	<bound method A.f of <class '__main__.A'>>
	>>>

Методи класа прив'язані до самого класа, а не його екземпляра. 
Вони можуть міняти стан класа, що відобразиться на усіх об'єктах цього класа, 
але не можуть міняти конкретний об`єкт. 

Приклад метода класа — `dict.fromkeys()` — повертає новий словник з переданими елементами 
в якості ключів: 

	>>> dict.fromkeys('abc')
	{'a': None, 'b': None, 'c': None}
	>>>
	
## Статичні методи

Статичні методи декларуються за допомогою наступного синтаксиса: 

	>>> class A:
	...     @staticmethod
	...     def f():
	...             pass
	...
	>>> A.f
	<function A.f at 0x0000028FECA8C1F0>
	>>>

Їх можна сприймати як методи, які "не знають, до якого вони класа чи об'єкта належать". 

Таким чином, статичні методи прикріплені до класа лише для зручності 
і не можуть міняти стан ні класа, ні його екземпляра. 

## До практики

Напишемо клас, де використовуються усі три види методів. 

	>>> class ToyClass:
	...     def instance_method(self):
	...         return 'instance method called', self
	...     @classmethod
	...     def class_method(cls):
	...         return 'class method called', cls
	...     @staticmethod
	...     def static_method():
	...         return 'static method called'
	...
	>>> obj = ToyClass()
	>>>

Розберемось з роботою методів. 
Спочатку метод екземпляра: 
	
	>>> obj.instance_method()
	('instance method called', <__main__.ToyClass object at 0x00000179B2FF4CA0>)
	>>>
	
Приклад вище підтверджує те, 
що метод `instance_method` має доступ до об'єкта класа `ToyClass` 
через аргумент `self`. 
Зауважте: метод `obj.instance_method()` можна викликати і так: 

	ToyClass.instance_method(obj)

Тепер скористаємось методом класа: 

	>>> obj.class_method()
	('class method called', <class '__main__.ToyClass'>)
	>>>

Як видно, 
метод класа `class_method()` має доступ до самого класа `ToyClass`, 
але не до його конкретного екземпляра. 
Пам'ятаєте що в Python усе є об'єкт? 
Клас — теж об'єкт, 
який ми можемо передати функції в якості аргумента. 

Викликаємо статичний метод: 

	>>> obj.static_method()
	'static method called'
	>>>

Статичні методи можна викликати через об'єкт класа. 
Статичному методу ніякі спеціальні аргументи (екземпляр чи клас) не передаються. 
Тобто статичні методи не можуть отримати доступ до параметрів класа чи об'єкта. 
Вони працюють тільки з тими даними, які їм передаються як аргументи. 

Тепер давайте викличемо ті ж самі методи, але на самому класі.

	>>> ToyClass.class_method()
	('class method called', <class '__main__.ToyClass'>)
	>>>
	>>> ToyClass.instance_method()
	Traceback (most recent call last):
	  File "<stdin>", line 1, in <module>
	TypeError: instance_method() missing 1 required positional argument: 'self'
	>>>

Помилка виникає тому, що `instance_method()` визначений з аргументом `self`, але викликаючи його безпосередньо на класі `ToyClass` без екземпляра, не передається необхідний аргумент для параметра `self`. 

Зі статичним методом нічого неочікуваного: 

	>>> ToyClass.static_method()
	'static method called'
	>>>

Розглянемо більш пракичний приклад для розуміння того, 
коли і який метод варто використовувати. 

```python
class Person:
	def __init__(self, name, age):
		self.name = name
		self.age = age

	@classmethod
	def from_string(cls, string):
		parts = string.split(',')
		name_str = parts[0]
		age_str = parts[1].strip()
		return cls(name=name_str, age=int(age_str))
		
	@staticmethod
	def is_adult(age):
		return age >= 18
```

Спробуємо створити об'єкт:

	>>> p = Person('Jane', 25)
	>>> p.age
	25
	>>>

Тепер викликаємо метод класа, який у свою чергу створить об'єкт цього ж класа і поверне його:

	>>> p2 = Person.from_string('Alice, 35')
	>>> p2.age
	35
	>>> p2
	<__main__.Person object at 0x000002DBFA880A10>
	>>>

І, нарешті, статичний метод класа `Person`: 

	>>> Person.is_adult(age=19)
	True
	>>>

Поширеною практикою використання класових методів є використання їх як "альтернативних конструкторів". 
У вищенаведеному прикладі ми створювали екземпляр класа `Person` двома способами:

	>>> p = Person('Jane', 25)
	>>> p2 = Person.from_string('Alice, 35')

А ось як можна створити словник використовуючи класовий метод `fromkeys()` класа `dict`:

	>>> d=dict.fromkeys('abc', 42)
	>>> d
	{'a': 42, 'b': 42, 'c': 42}
	>>>


## Резюме

- Статичні методи (staticmethod) використовуються для функціональності, яка не потребує доступу до данних класу чи екземпляра. Наприклад, утиліти та функції обробки.
- Класові методи (classmethod) використовуються для створення альтернативних конструкторів чи функціональності, пов'язаної тільки з класом, а не з екземпляром.
- Методи екземплярів використовуються для функціональності, яка працює з даними та станом конкретного екземпляра класу. Це найпоширеніший тип методу.