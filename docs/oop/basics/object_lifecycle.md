---
hide:
#  - navigation # Hide navigation
 - toc        # Hide table of contents
---

# Життєвий цикл об'єкта

Коли ви створюєте власний клас, а потім екземпляр цього класа, 
то щойно створений екземпляр вже буде мати певну кількість атрибутів:

	>>> class SomeClass:
	...     pass
	...
	>>> obj = SomeClass()
	>>> dir(obj)
	['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__']
	>>>


## Спеціальні атрибути

Атрибути, імена яких починаються і закінчуються двома знаками підкреслення, 
є "внутрішніми" для Python. 
Вони задають особливі властивості об'єктів. 

Приклади імен таких атрибутів:

- `__doc__`
- `__class__`
- `__init__`
- `__bool__`


Серед спеціальних атрибутів є як дані, так і методи. 
У документації Python такі методи називаються "метод зі спеціальними іменами", 
однак у спільноті розробників найчастіше такі методи називають: 

- магічний метод (magic method) 
- спеціальний метод (special method) 
- dunder method (від англ. Double UNDERscore — подвійний знак підкреслення)

Спеціальні методи задають особливу поведінку об'єктів і як правило не викликаються напряму. 
Їх викликає «у потрібні моменти часу» інтерпретатор. 
Але при створенні класа ми можемо визначити свій власний спеціальний метод, іншими словами перевизначити метод. Це дозволяє, наприклад, змінити поведінку вбудованих функцій і операторів для екземплярів певного класа. 

Не слід створювати свої власні (нестандартні) спеціальні атрибути!

## Життєвий цикл екземпляра класа

При створенні екземпляра класа інтерпретатор автоматично викликає послідовно два спеціальних метода: 
`__new__` та `__init__`. 
На іншому кінці життєвого цикла об'єкта знаходиться метод `__del__`. 
Давайте детальніше розглянемо ці три магічних метода. 

### `__new__(cls, [...])`

Це перший метод, який буде викликано при створенні об'єкта. 
Власне це і є "створювач" екземплярів класа. 
В парадигмі ООП такий метод називається конструктором. 

Конструктор приймає в якості параметрів клас і потім будь-які інші аргументи, 
які було вказано при створенні екземпляра. 
Наприклад:

	x = SomeClass(10, 'foo')
	
Конструктору буде передано: 

- клас SomeClass
- значення 10 типу int
- значення 'foo' типу str

Усі аргументи у подальшому буде передано спеціальному методу `__init__()`. 

В Python конструктор перевизначається вкрай рідко, лише для вирішення певних спеціальних задач. 

### `__init__(self, [...])`

Ініціалізатор класа. 
Йому передається екземпляр класа а також усе, з чим було викликано конструктор. 

Ініціалізатор майже повсемістно використовується при визначенні класів. 
Майже завжди цей метод помилково називають конструктором. 

### `__del__(self)`

Викликається при знищенні екземпляра. 
В парадигмі ООП такий метод називається деструктором. 

Деструктор не визначає поведінку для оператора `del`. 
Він визначає поведінку об'єкта у той час, коли за об'єкт береться збиральник сміття. 
Тому наступні рядки коду не є еквівалентними: 

	del x
	x.__del__()

<!--
Це може бути доволі зручно для об'єктів, які можуть потребувати додаткових "чисток" під час видалення, наприклад сокети чи файлові об'єкти. 
Однак пам'ятайте, що `del` не може слугувати заміною для хороших програмістських практик. 
Завжди завершуйте з'єднання, якщо закінчили з нми працювати і так далі! 
-->
Фактично, через відсутність гарантії виклику у визначений момент, 
деструктор в Python не повинен використовуватись майже ніколи. 
Використовуйте його з обережністю! 

