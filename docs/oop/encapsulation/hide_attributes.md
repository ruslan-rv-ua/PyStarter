---
hide:
#  - navigation # Hide navigation
 - toc        # Hide table of contents
---

# Приховування атрибутів

В багатьох мовах програмування, які підтримують парадигму ООП, існують спеціальні модифікатори доступу атрибутів. 
Вони явно вказують, чи можна мати доступ до певного атрибуту класа "ззовні", або ж цей атрибут доступний тільки всередині класа. 

В Python механізму модифікаторів доступу не існує. 
Для імітації приховування атрибутів в Python використовується домовленість 
згідно якої якщо ідентифікатор атрибута починається з знака підкреслення, 
то цей атрибут призначено виключно для внутрішнього використання. 

```python
class Person:
    def __init__(self, name, age):
        self._name = name
        self._age = age
    def __repr__(self):
        return f'Person({self._name}, {self._age})'
```

Але домовленість — це не синтаксичне правило мови програмування, і при великому бажанні її можна порушити:

	>>> p = Person('Alice', 35)
	>>> p._age
	35
	>>>

Звісно, що порушувати домовленості — річ погана.

Можна ще більше приховати атрибут класа. 
Для цього його ідентифікатор має починатись не з одного, а з двох знаків підкреслення: 

```python
class Person:
    def __init__(self, name, age):
        self.__name = name
        self.__age = age
    def __repr__(self):
        return f'Person({self.__name}, {self.__age})'

```	

Невже якщо ідентифікатор атрибута починається з символів `__`, то до нього не можна отримати доступ ззовні класа? 
Насправді можна, але вже трохи важче. 
Необхідно вказати атрибут класа таким чином:

1. символ підкреслення
1. ім'я класа
1. ім'я атрибута як у класі, тобто з двома підкресленнями на початку

Такий механізм приховування імен в Python називається "спотворення імен" (name mangling). 

Отже для вищенаведеного прикладу щоб таки дістатись до атрибута `__age`: 

	>>> p = Person('Alice', 35)
	>>> p._Person__age
	35
	>>>

Зауважте, що це знову ж таки домовленість. 
В результаті "атрибут як він є" стає  замаскованим. 
Ззовні класа такого атрибута просто не існує. 

	>>> p
	Person(Alice, 35)
	>>> p.__age
	Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
	AttributeError: 'Person' object has no attribute '__age'
	>>> p.__age = 'twenty two'
	>>> p.__age
	'twenty two'
	>>> p
	Person(Alice, 35)
	>>> dir(p)
	['_Person__age', '_Person__name', ....]
	>>>

Для програміста наявність двох символів підкреслення перед іменем атрибута повинно сигналізувати, 
що чіпати його поза класом не слід взагалі. 

