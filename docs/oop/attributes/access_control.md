---
hide:
#  - navigation # Hide navigation
 - toc        # Hide table of contents
---

# Контроль доступу до атрибутів

Python надає потужні інструменти для керування доступом до атрибутів класів.
Контроль доступу до атрибутів здійснюється за допомогою спеціальних методів класу. 

### `__getattr__`

За допомогою цього магічного метода можна визначити поведінку для випадків, коли є  спроба звернутись до атрибута, якого не існує (зовсім чи поки що). 
Це може бути використано, наприклад, для перехоплення і попередження про використання застарілих атрибутів, при цьому можна все ж таки обчислити і повернути цей атрибут. 

```python
`__getattr__(self, attr_name)
```

**Параметри:**

- `attr_name` — ім'я атрибуту, який намагаэмось отримати).

**Приклад:**

```python
class Example:
    def __getattr__(self, attr_name):
        print(f'Attribute `{attr_name}` not found')

obj = Example()
obj.undefined_attribute
# Attribute `undefined_attribute` not found
```

!!! note "Зауважте:"
	цей метод буде викликано тільки коли намагаються отримати доступ до неіснуючого атрибута.





### `__setattr__(self, name, value)`

Цей метод дозволяє визначити поведінку для присвоєння значення атрибуту, незалежно від того існує атрибут чи ні. Тобто, можна визначити будь-які правила для будь-яких змін значення атрибутів.

```python
__setattr__(self, attr_name, value)
```

**Параметри:**

- `attr_name` — ім'я атрибуту, якому ви намагаєтесь присвоїти значення.
- `value` — нове значення для атрибуту.

**Приклад:**

```python
class Example:
    def __setattr__(self, attr_name, value):
        print(f'Setting attribute `{attr_name}` to {value}')

obj = Example()
obj.my_attribute = 42
# Setting attribute `my_attribute` to 42
```


 
### `__delattr__`

Магічний метод `__delattr__` в Python 
Викликається при спробі видалення атрибуту об'єкту за допомогою оператора `del`. 

```python
__delattr__(self, attr_name)
```

**Параметри:**

- `attr_name` — ім'я атрибуту, який ви намагаєтесь видалити.

**Приклад:**

```python
class Example:
    def __delattr__(self, attr_name):
        print(f'Deleting attribute `{attr_name}`')

obj = Example()
obj.my_attribute = 42

del obj.my_attribute
# Deleting attribute `my_attribute`
```


### `__getattribute__`

Цей метод дозволяє визначити поведінку для кожного випадка доступу до атрибутів (не тільки до неіснуючих, як `__getattr__`). 
Не рекомендується використовувати цей метод, оскільки випадків, коли він дійсно корисний дуже мало (набагато рідше потрібно перевизначати поведінку при отриманні, а не при встановленні значення) і реалізувати його без можливих помилок важко.

```python
__getattribute__(self, attr_name)
```

**Параметри:**

- `attr_name` — ім'я атрибуту, який ви намагаєтесь отримати.


-------

!!! warning "Обережно!"
	Можна дуже легко отримати проблеми при визначенні будь-якого метода, які керують доступом до атрибутів:

```python
class A:
	def __setattr__(self, name, value):
		self.name = value
```	

Вищенаведений приклад приведе до нескінченної рекурсії! Кожного разу, коли в методі `__setattr__()` буде виконуватись 'self.name = value', знову буде викликано метод `методі `__setattr__()` і так до тих пір, поки усе не "впаде". 

Як же бути? 

У кожного класа є спеціальний атрибут `__dict__`. Це словник, в якому містяться усі атрибути і їх значення. Отже можна скористатись цим "спеціальним" атрибутом:

```python
class A:
    def __setattr__(self, name, value):
        self.__dict__[name] = value
```
