---
hide:
#  - navigation # Hide navigation
 - toc        # Hide table of contents
---

# Лінеаризація

Як ми вже з'ясували, дочірній клас може не мати певного атрибута, але він може успадкувати його від базового класа. 
Для пошуку атрибутів в ієрархії класів використовується лінеаризація класів.

> ***Лінеаризація*** — це черговість, при якій проводиться пошук зазначеного атрибута в ієрархії класів.

Використовуючи лінеаризацію відбувається пошук атрибутів в ієрархії класів. 
При простому успадкуванні алгоритм пошуку атрибутів виглядає наступним чином: 

- якщо атрибут, до якого відбувається доступ, не знайдено в поточному класі, то виконується його пошук в базовому класі
- якщо атрибут не знайдено і в базовому класі, то виконується його пошук в базовому класі базового класа
- пошук відбувається рекурсивно аж до класа `object`
- якщо атрибут не знайдено і в класі `object`, то отримуємо вийняткову ситуацію

Приклад:

```python
class Person:
    def __init__(self, name):
        self.name = name
    def hello(self):
        print(f'Я — {self.name}')

class Employee(Person):
    def salary(self):
        print('Я отримую зарплатню')

class Manager(Employee):
    def salary(self):
        print('Я отримую підвищену зарплатню')
    def info(self):
        print('Я можу керувати іншими')
```		

У вищенаведеному прикладі клас `Manager`: 

- від класа `Person` успадкував метод `hello()`
- від класа `Employee` метод `salary()` не успадковується, клас має власний метод `salary()`
- має власний метод `info()`

Перевіримо на практиці: 

	>>> m = Manager('Дмитро')
	>>> m.hello()
	Я — Дмитро
	>>> m.info()
	Я можу керувати іншими
	>>> m.salary()
	Я отримую підвищену зарплатню
	>>>

## Порядок вирішення методів

В Python лінеаризація також має назву `MRO` — "Method Resolution Order", 
порядок вирішення методів. 
Назва може трошки вводити в оману, 
тому що таким чином відбувається пошук не тільки методів, а й будь-яких атрибутів. 
	
Лінеаризація для певного класа знаходиться в його спеціальному атрибуті `__mro__`:
	
	>>> Manager.__mro__
	(<class '__main__.Manager'>, <class '__main__.Employee'>, <class '__main__.Person'>, <class 'object'>)
	>>>

Але частіше користуються методом класа, який повертає не кортеж, а одразу список:

	>>> Manager.mro()
	[<class '__main__.Manager'>, <class '__main__.Employee'>, <class '__main__.Person'>, <class 'object'>]
	>>>

Ми отримали всю ієрархію успадкування, аж до класа `object`. 

## Перевірка об'єкта на належність класу

В Python є будована функція: 

	isinstance(obj, cls)
	
Повертає `True` якщо об'єкт `obj` є екземпляром класа `cls` або його суперкласів. 
Тобто перевірка відбувається по усій ієрархії успадкування: 

	>>> isinstance(m, Manager)
	True
	>>> isinstance(m, Employee)
	True
	>>> isinstance(m, object)
	True
	>>> isinstance(m, str)
	False
	>>> isinstance(Person('Bob'), Manager)
	False
	>>>

Другим аргументом можна передати одразу декілька класів об'єднавши їх у кортеж. 
У цьому разі відбуватиметься перевірка належності об'єкта до ієрархій одразу декількох класів: 

	>>> isinstance(m, (Employee, Person))
	True
	>>> isinstance(m, (Employee, object))
	True
	>>> isinstance(m, (Employee, list))
	True
	>>> isinstance(m, (dict, list))
	False
	>>>
