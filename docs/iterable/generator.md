---
hide:
#  - navigation # Hide navigation
 - toc        # Hide table of contents
---

# Генератори

Генератори — дуже потужний механізм в Python початково створений для спрощення написання ітераторів, але за допомогою якого можна вирішувати і деякі інші задачі, зокрема написання асинхроного коду.

Термін ***генератор*** (generator), в залежності від контекста, може означати або функцію-генератор, або ітератор генератора.

> ***Функція-генератор*** (generator function) — це функція, яка повертає спеціальний *ітератор генератора* (generator iterator) або (інша назва) об'єкт-генератор (generator object). 

Така функція характеризується наявністю ключового слова `yield`. Якщо в функції присутнє ключове слово `yield`, тоді Python створить не об'єкт функції, а об'єкт функції-генератора. 

Коли викликається функція-генератор, її код, на відміну звичайним функціям, насправді не виконується. Замість цього функція-генератор повертає спеціальний об'єкт генератора, який також є ітератором. А вже коли виконується ітерування по цьому об'єкту, вже тоді виконується код функції-генератора, причому виконується як би "порціями".

Код функції генератора виконується доти, доки не зустрінеться ключове слово `yield`. Інструкція `yield` як би ставить на паузу виконання і заморожує стан функції-генератора і повертає чергове значення генератора (або ж ітератора, у данному випадку це одне й те ж саме). Після наступного виклика `__next__()` функція-генератор продовжує своє виконання з того місця, де його було призупинено.

Коли виконання функції-генератора завершується (за допомогою ключового слова `return` або ж  при досягненні кінця функції), піднімається виняток `StopIteration`.

Перевага використання генераторів для створення ітераторів полягає у тому,  що магічні методи `__iter__` і `__next__` для генераторів створюються автоматично. Ми у функції-генераторі просто описуємо логіку (алгоритм) для отримання чергового значення.

Давайте розглянемо на прикладі. Створимо найпростіший генератор:

	>>> def gen():
	...     yield 'Hello'
	...     yield 'world'
	...
	...
	>>>	
	
Спершу може здатись, що це звичайнісінька собі функція:

	>>> gen
	<function gen at 0x0000017E2A663E18>
	>>>

Але якщо ми викличемо таку функцію, то вона поверне об'єкт генератор:

	>>> g = gen()
	>>> g
	<generator object gen at 0x0000017E2A72D308>
	>>>

У цього об'єкта є метод `__iter__()`, отже це ітерабельний об'єкт:

	>>> g.__iter__
	<method-wrapper '__iter__' of generator object at 0x0000017E2A72D308>
	>>>

Крім того є і метод `__next__()`, отже це і ітератор також:

	>>> g.__next__
	<method-wrapper '__next__' of generator object at 0x0000017E2A72D308>
	>>>
	
Окей, тоді давайте проітеруємось по ньому:

	>>> next(g)
	'Hello'
	>>> next(g)
	'world'
	>>> next(g)
	Traceback (most recent call last):
	  File "<stdin>", line 1, in <module>
	StopIteration
	>>>
	
Проітеруємось за допомогою `for`:

	>>> for i in gen(): print(i)
	...
	Hello
	world
	>>>
	


	
	
#### Лічилочка

	>>> def counting_out(max_count):
	...     count = 1
	...     while count <= max_count:
	...             yield count
	...             count += 1
	...
	>>> for i in counting_out(5): print(i)
	...
	1
	2
	3
	4
	5
	>>>
	
	
	
	
	
	
#### Фібоначчі-генератор

Створимо генератор, який буде повертати нам числа з послідовності Фібоначчі довжиною `count`:

```python
def fibonacci_generator(count):
    a, b = 0, 1
    for _ in range(count):
        yield b
        a, b = b, a + b
```

Тепер можна генерувати числа Фібоначчі:

	>>> for f in fibonacci_generator(10): print(f)
	...
	1
	1
	2
	3
	5
	8
	13
	21
	34
	55
	>>> list(fibonacci_generator(10))
	[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
	>>>



### Делегування в генераторах

Припустимо стоїть задача проітеруватись послідовно по двом спискам. Зробимо це за допомогою генератора:

```python
def iter_lists(list1, list2):
    for item in list1:
        yield item
    for item in list2:
        yield item
```

У наведеному коді кожен цикл `for` фактично отримує і використовує ітератор списка, 
а генератор при кожній ітерації повертає "згенероване" значення. 

В генераторах є можливість як би делегувати повернення значень з ітерабельних об'єктів. 
Робиться це за допомогою наступного синтаксиса:

	yield from <expression>

де `<expression>` — вираз, який повертає ітерабельний об'єкт. 

Тепер вищенаведений генератор можна записати простіше:

```python
def iter_lists(list1, list2):
    yield from list1
    yield from list2
```

А можна створити генератор який буде послідовно повертати значення з усіх переданих йому ітерабельних об'єктів:

```python
def chain_iterables(*iterables):
    for iterable in iterables:
        yield from iterable
```

Тепер можна зробити "ланцюжок" з елементів декількох ітерабельних:

	>>> list(chain_iterables(
	...     [42, 'Hello'],
	...     'abc',
	...     range(1,5)
	... ))
	[42, 'Hello', 'a', 'b', 'c', 1, 2, 3, 4]
	>>>

