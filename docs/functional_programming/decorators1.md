---
hide:
#  - navigation # Hide navigation
 - toc        # Hide table of contents
---

# Декоратори в Python

> ***Декоратор*** —  це шаблон проектування, який дозволяє модифікувати роботу функції, обернувши її в іншу функцію. Зовнішня функція називається декоратором, який приймає як аргумент вихідну функцію та повертає її модифіковану версію.

!!! note "Примітка:"
	Фактично декоратор — це callable об’єкт (будь-який об’єкт, який реалізує спеціальний метод `__call__()`), який повертає callable об’єкт.

### Декоруємо подарунки

Уявімо, що у нас є певний предмет, який ми хочемо комусь подарувати. 
Давайте оформимо цей подарунок як функцію:

	>>> def gift_function():
	...     print('Я — подарунок!')
	...
	>>> gift_function()
	Я — подарунок!
	>>>

Але щоб наш подарунок виглядав привабливо, давайте обгорнемо його у святкове упакування. 
Упакування ми теж представимо функцією, яка буде в якості аргумента приймати наш подарунок:

	>>> def wrap_function(gift_to_wrap_function):
	...     print('Я — святкова обгортка! Я обгорну подарунок.')
	...     gift_to_wrap_function()
	...     print('Подарунок обгорнуто!')
	...
	>>> wrap_function(gift_function)
	Я — святкова обгортка! Я обгорну подарунок.
	Я — подарунок!
	Подарунок обгорнуто!
	>>>

І уявімо собі людину, яка займається обгортанням подарунків у святкове упакування. Назвемо її "декоратором".

Що потрібно декоратору? Упакування у нього вже є, він добре підготувався до виконання своїх обов'язків. Отже йому лише треба дати той подарунок, який треба "декорувати" святковою обгорткою.

Що буде робити декоратор? Візме упакування, обгорне ним подарунок, і поверне вже упакований подарунок.

Декоратор у нас теж буде функцією:

	>>> def decorator_function(gift_to_wrap_function):
	...     def wrap_function():
	...             print('Я — святкова обгортка! Я обгорну подарунок.')
	...             gift_to_wrap_function()
	...             print('Подарунок обгорнуто!')
	...     return wrap_function
	...
	>>> decorated_gift_function = decorator_function(gift_function)

Давайте подивимось що ми тепер маємо:

	>>> gift_function()
	Я — подарунок!
	>>> decorated_gift_function()
	Я — святкова обгортка! Я обгорну подарунок.
	Я — подарунок!
	Подарунок обгорнуто!
	>>>

Упс... Два подарунки — декорований і не декорований! 
А має ж бути один подарунок — просто той, що був раніше недекорованим має стати декорованим. 
Давайте виправимо це непорозуміння:

	>>> gift_function = decorator_function(gift_function)
	>>> gift_function()
	Я — святкова обгортка! Я обгорну подарунок.
	Я — подарунок!
	Подарунок обгорнуто!
	>>>
	
Те, що треба! Віддали подарунок декоратору, і отримали його вже декорованим.
	
Які можна зробити висновки на даний момент?

Ми взяли функцію, за допомогою декоратора додали до неї певний функціонал, і таким чином отримали цю функцію, але вже "покращену".


### Декоруємо зручно!

Декоратори — дуже корисна і зручна штука, і на практиці декоратори застосовуються досить часто. Тому для декораторів в Python придумали спеціальний синтаксис, який дозволяє використовувати декоратори більш зручно. 
З вищенаведеного прикладу наступний запис:

	>>> def gift_iphone():
	...     print('Я — айфон!')
	...
	>>> gift_iphone = decorator_function(gift_iphone)

буде ідентичним такому:

	>>> @decorator_function
	... def gift_iphone():
	...     print('Я — айфон!')
	...
	>>> gift_iphone()
	Я — святкова обгортка! Я обгорну подарунок.
	Я — айфон!
	Подарунок обгорнуто!
	>>>
	
Тобто спочатку вказуємо ім'я декоратора після значка `@`, і на наступному рядку ту функцію, яку треба декорувати вищенаведеним декоратором. 
