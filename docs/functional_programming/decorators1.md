---
hide:
#  - navigation # Hide navigation
 - toc        # Hide table of contents
---

# Декоратори в Python

> ***Декоратор*** —  це шаблон проектування, який дозволяє модифікувати роботу функції, обернувши її в іншу функцію. Зовнішня функція називається декоратором, який приймає як аргумент вихідну функцію та повертає її модифіковану версію.

!!! note "Примітка:"
	Фактично декоратор — це callable об’єкт (будь-який об’єкт, який реалізує спеціальний метод `__call__()`), який повертає callable об’єкт.

### Декоруємо подарунки

Уявімо, що у нас є певний предмет, який ми хочемо комусь подарувати. 
Давайте оформимо цей подарунок як функцію:

```python
def gift():
	print('Подарунок.')
```

Але щоб наш подарунок виглядав привабливо, давайте обгорнемо його у святкове упакування. 
Упакування ми теж представимо функцією, яка буде в якості аргумента приймати наш подарунок:

```python
def wrapper():
	print('Я — святкова обгортка! Я обгорну подарунок.')
	gift()
	print('Подарунок обгорнуто!')
```

Обгорнемо подарунок, інакше кажучи "декоруємо" його:

	>>> wrapper()
	Я — святкова обгортка! Я обгорну подарунок.
	Подарунок.
	Подарунок обгорнуто!
	>>>

І уявімо собі людину, яка займається обгортанням подарунків у святкове упакування. Назвемо її "декоратором".

Що потрібно декоратору? Упакування у нього вже є, він добре підготувався до виконання своїх обов'язків. 
Отже йому лише треба дати той подарунок, який треба "декорувати" святковою обгорткою.

Що буде робити декоратор? Візме упакування, обгорне ним подарунок, і поверне вже упакований подарунок.

Декоратор у нас теж буде функцією:

```python
def decorator(gift):
	def wrapper():
		print('Я — святкова обгортка! Я обгорну подарунок.')
		gift()
		print('Подарунок обгорнуто!')	
	return wrapper

decorated_gift = decorator(gift)
```

Давайте подивимось що ми тепер маємо:

	>>> decorated_gift()
	Я — святкова обгортка! Я обгорну подарунок.
	Подарунок.
	Подарунок обгорнуто!
	>>> gift()
	Подарунок.
	>>>

Упс... Два подарунки — декорований і не декорований! 
А має ж бути один подарунок — просто той, що був раніше недекорованим має стати декорованим. 
Давайте виправимо це непорозуміння:

```python
def gift():
	print('Подарунок.')

def decorator(gift):
	def wrapper():
		print('Я — святкова обгортка! Я обгорну подарунок.')
		gift()
		print('Подарунок обгорнуто!')	
	return wrapper

gift = decorator(gift)
```

Gодивимось що маємо тепер:

	>>> gift()
	Я — святкова обгортка! Я обгорну подарунок.
	Подарунок.
	Подарунок обгорнуто!
	>>>

Те, що треба! Віддали подарунок декоратору, і отримали його вже декорованим.
	
Ми взяли функцію, за допомогою декоратора додали до неї певний функціонал, і таким чином отримали цю функцію, але вже "покращену".


### Декоруємо зручно!

Декоратори — дуже корисна і зручна штука, і на практиці декоратори застосовуються досить часто. Тому для декораторів в Python придумали спеціальний синтаксис, який дозволяє використовувати декоратори більш зручно. 
З вищенаведеного прикладу наступний запис:

```python
def iphone():
	print('Айфон.')

iphone = decorator(iphone)
```

буде ідентичним такому:

```python
@decorator
def iphone():
	print('Айфон.')
```

Тобто спочатку вказуємо ім'я декоратора після значка `@`, 
і на наступному рядку ту функцію, яку треба декорувати вищенаведеним декоратором. 

### Ланцюжки з декораторів

Синтаксис Python дозволяє одночасне використання декількох декораторів.

```python
def bread(func):
	def wrapper():
		print('Хліб')
		func()
		print('Хліб')
	return wrapper

def salad(func):
	def wrapper():
		print('Зеленина')
		func()
		print('Зеленина')
	return wrapper

@bread
@salad
def stake():
	print("М'ясо")
```

Приготуємо сендвіч:

	>>> stake()
	Хліб
	Зеленина
	М'ясо
	Зеленина
	Хліб
	>>>

А ось застосування тих самих декораторів, але без "магічного" символа `@`:

```python
stake = bread(salad(stake))
```

Зауважте що послідовність застосування декораторів має значення:

```python
@salad
@bread
def stake():
	print("М'ясо")
```

Отримаємо зовсім інший сендвіч:

	>>> stake()
	Зеленина
	Хліб
	М'ясо
	Хліб
	Зеленина
	>>>


<!-- 
### Декоруємо функції з параметрами

У попередніх прикладах ми декорували функції, які не мали ніяких параметрів. А як щодо функцій з параметрами?

		
		

Припустимо маємо таку функцію:

	:::python
	>>> def div(a, b):
	...     return a / b
	...
	>>>
	
При певних умовах ми отримаємо помилку:
	
	:::python
	>>> div(2, 0)
	Traceback (most recent call last):
	  File "<stdin>", line 1, in <module>
	  File "<stdin>", line 2, in div
	ZeroDivisionError: division by zero
	>>>

Давайте спробуємо створити декоратор, який буде перевіряти вхідні параметри функції:

	:::python
	>>> def smart_div(func):
	...     def wrapper(a, b):
	...             print("I am going to divide",a,"and",b)
	...             if b == 0:
	...                     print("Oops! cannot divide")
	...                     return
	...             return func(a, b)
	...     return wrapper
	...
	>>>

Такий варіант поверне `None` якщо умова спрацює:

	:::python
	>>> @smart_div
	... def div(a, b):
	...     return a / b
	...
	>>> div(1, 0)
	I am going to divide 1 and 0
	Oops! cannot divide
	>>> div(1, 1)
	I am going to divide 1 and 1
	1.0
	>>>

Можна зауважити, параметри вкладеної функції-обгортки `wrapper()` всередині декоратора такі самі як і у функції, що декорується. Знаючи це ми можемо створити "загальний" декоратор, який буде працювати з будь-якою кількістю параметрів.










Напишемо декоратор, який буде повідомляти нам, що ми передали функції, яку він декорує:

	:::python
	>>> def works_for_all(func):
	...     def wrapper(*args, **kwargs):
	...             print('I got next parameters:', args, kwargs)
	...             return func(*args, **kwargs)
	...     return wrapper
	...
	>>> @works_for_all
	... def f(a, b):
	...     pass
	...
	>>> f('string', b=123)
	I got next parameters: ('string',) {'b': 123}
	>>>
	 -->
