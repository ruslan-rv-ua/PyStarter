---
hide:
#  - navigation # Hide navigation
 - toc        # Hide table of contents
---

# Класичні функції вищого порядка

Розглянемо "класичні" функції вищого порядка, 
які приймають ітерабельні об'єкти і функції. 

### `map()`

Використовується для застосування заданої функції до кожного елемента в ітерабельному об'єкті 
(або декількох ітерабельних об'єктів) 
та повертає ітератор результатів.

    map(function, *iterables)

Аргументи:

- `function` — функція, яка буде застосована до кожного елемента ітерабельного об'єкта;
- `iterables` — ітерабельні об'єкти.

Приклад. Є символьний рядок, у якому числа розділено пробілами. Треба отримати список цих чисел:

	>>> string = '2 4 8 15 42'
	>>> numbers = map(int, string.split())
	>>> list(numbers)
	[2, 4, 8, 15, 42]
	>>>

Функції map() ми передали функцію int і список з символьних рядків, до елементів якого і було застосовано цю функцію.

Ще приклади:

```
>>> list(map(lambda x: x**2, [1, 2, 3, 4, 5]))
[1, 4, 9, 16, 25]
>>> list(map(int, ['1', '2', '3', '4', '5']))
[1, 2, 3, 4, 5]
>>> list(map(str.upper, ['hello', 'world']))
['HELLO', 'WORLD']
```


### `filter()`

Функція `filter()` використовується для фільтрації елементів у ітерабельному об'єкті за допомогою заданої функції та повертає ітератор, що містить лише ті елементи, для яких функція повертає `True`.

    filter(function, iterable)

Аргументи:

- `function` — функція, яка повертає `True` або `False`;
- `iterable` — ітерабельний об'єкт.


```
>>> list(filter(lambda x: x % 2 == 0, [1, 2, 3, 4, 5]))
[2, 4]
>>> list(filter(str.isdigit, ['a', '1', 'b', '2', 'c', '3']))
['1', '2', '3']
>>> list(filter(lambda s: len(s) > 3, ['apple', 'banana', 'kiwi', 'orange']))
['apple', 'banana', 'orange']
```



### `reduce()`

Використовується для послідовного застосування заданої функції до всіх елементів ітерабельного об'єкта, зводячи їх до одного значення.

    reduce(function, iterable[, initializer])

Аргументи:

- `function` — бінарна функція, яка приймає два аргументи і повертає результат;
- `iterable` — ітерабельний об'єкт;
- `initializer` (опційно) — початкове значення аккумулятора. Якщо не задано, то береться перший елемент ітерабельного об'єкта.

Якщо задано значення акумулятора, тоді для акумулятора і для першого елемента послідовності викликається задана функція. Якщо ж значення акумулятора не задано, функція викликається для перших двох елементів. 
Результат дії заданої функції записується в акумулятор. 
Далі процес повторюється для усіх елементів ітерабельного об'єкта.

Приклад: є список чисел, треба отримати їх добуток. 

	>>> from functools import reduce
	>>> numbers = [1, 2, 3, 4, 5]
	>>> product = reduce(lambda a, x: a*x, numbers)
	>>> product
	120

Функції `reduce()` ми передали анонімну функцію, яка повертає добуток двох чисел. 
Ця функція застосовується спершу до чисел 1 і 2, в результаті отримуємо 2. 
Потім до чисел 2 (попередній результат) і 3 (наступний елемент списка), вийде 6. 
Потім до чисел 6 і 4, і врешті решт до чисел 24 і 5. 

Ще один приклад. 
Є список списків чисел:

	[[1, 2, 3], [4, 5], [6, 7, 8]]
	
Треба отримати один список який міститиме усі числа: 

	[1, 2, 3, 4, 5, 6, 7, 8]
	
За допомогою `reduce()` це можна зробити просто і елегантно: 

	>>> nums = [[1, 2, 3], [4, 5], [6, 7, 8]]
	>>> l = reduce(lambda x,y: x+y, nums)
	>>> l
	[1, 2, 3, 4, 5, 6, 7, 8]
	>>>

Ще можна замість анонімної функції використати магічний метод класа `list`:

	>>> l = reduce(list.__add__, nums)
	>>> l
	[1, 2, 3, 4, 5, 6, 7, 8]
	>>>

Функція `reduce()` — це "класика" агрегування даних. 
Ось як наприклад можна реалізувати функцію `sum()`:

    reduce(lambda x, y: x + y, iterable)

А ось реалізація `max()`:

    reduce(lambda x, y: x if x > y else y, iterable)

