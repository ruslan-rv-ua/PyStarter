---
hide:
#  - navigation # Hide navigation
 - toc        # Hide table of contents
---


# Замикання

> ***Замикання*** (closure) — це функція, яка зберігає посилання на змінні з охоплюючої функції, 
в якії вона була визначена. При цьому змінні охоплюючої функції не передаються як аргументи в функцію-замикання, але все одно доступні для неї. Це дозволяє функції-замиканню використовувати ці змінні навіть після завершення роботи охоплюючої функції.

Розглянемо приклад:

```python
def outer():
    message = 'Python rocks!'
    def inner():
        print(message)
    return inner
```

Подивимось що відбувається коли ми викликаємо функцію `outer`:

1. Створюється локальна змінна `message`.
1. Створюється локальна функція `inner`:
    1. Всередині функції `inner` "згадується" змінна `message`.
    1. Оскільки функція `inner` не має локальної змінної `message`, Python знаходить цю змінну в області видимості `enclosure`, тобто в функції `outer`. 
    1. Змінну `message` в функції `inner` називають "вільною змінною" (free variable).
    1. Функція `inner()` як би "замикається" на змінну `message` з функції `outer`.
1. Як результат функції `outer` повертається замикання, тобто функція `inner` разом з вільною змінною `message`.

У наведеному вище прикладі `outer` — охоплююча функція, 
а `inner` — функція-замикання. 
`inner` використовує змінну `message` з охоплюючої функції, яка не передається функії `inner` як аргумент.
Таким чином, `inner` стає замиканням, яке зберігає посилання на `message` і може використовувати його навіть після завершення роботи `outer`.

!!! attention "Зауважте:"
    Замикання створюється коли виконується охоплююча функція `outer`, інакше кажучи коли створюється функція `inner`.

Створимо замикання:

    >>> closure = outer()
    >>> closure
    <function outer.<locals>.inner at 0x000001D684439080>
    >>> closure.__code__.co_freevars # вільні змінні
    ('message',)
    >>> closure.__closure__ # замикання
    (<cell at 0x0000022631DF9E40: str object at 0x0000022631E05AF0>,)
    >>> closure.__closure__[0].cell_contents # значення вільної змінної
    'Python rocks!'
    >>>


### Замикання з параметрами

```python
def outer():
    message = 'rocks!'
    def inner(who):
        print(f'{who} {message}')
    return inner
```

У наведеному прикладі замикання `inner` має параметр. 
Тепер замиканню можемо передавати певні значення:

    >>> closure = outer()
    >>> closure('Python')
    Python rocks!
    >>> outer()('Rust')
    Rust rocks!
    >>>

### Фабрика функцій

Зробимо ще цікавіше — охоплюючу функцію зробимо з параметрами:

```python
def outer(message):
    def inner(who):
        print(f'{who} {message}!')
    return inner
```

У цьому прикладі функція `inner` "замикається" на змінну `message` функції `outer` яка у свою чергу є параметром останньої.

Функція `outer` є як би "фабрикою" інших функцій, при цьому функції вона може "виробляти" з різними властивостями.

    rocks = outer('rocks')
    >>> rocks('Python')
    Python rocks!
    >>> sucks = outer('sucks')
    >>> sucks('Java')
    Java sucks!
    >>> rocks('Rust')
    Rust rocks!
    >>>


Розглянемо ще один приклад "функцій на замовлення". Є квадратична функція:

> *f(x)=ax²+bx+c*

Тут `a`, `b` та `c` — це константи, а `x` є параметром функції.

Давайте напишемо "фабрику" квадратичних функцій. 
"Фабриці" ми будемо передавати константи `a`, `b`, 'c', 
а "вироблятиме" вона квадратичні функції з цими заданими параметрами:

```python
def quadratic_function(a, b, c):
    def f(x):
        return a*x*x + b*x + c
    return f
```

Тепер можемо "виробити" стільки квадратичних функцій, скільки нам треба:

    >>> f1 = quadratic_function(1, 0, 0) # f(x) = x²
    >>> f1(5)
    25
    >>> f1(9)
    81
    >>>
    >>> f2 = quadratic_function(2, 2, 2) # f(x) = 2x² + 2x + 2
    >>> f2(1)
    6
    >>>

### Модифікація вільних змінних

Ми можемо модифікувати значення Змінних, на які "замикається" внутрішня функція. 
Треба лише вказати що змінні нзаходяться в області видимості зовнішньої функції:

```python
def counter():
    count = 0
    def inc():
        nonlocal count
        count += 1
        return count
    return inc
```

Функція `counter` "виготовляє" лічильники — функції-замикання, які при кожному виклику повертають кожного разу збільшене на 1 число починаючи з 1:

    >>> c1 = counter()
    >>> c2 = counter()
    >>> c1()
    1
    >>> c1()
    2
    >>> c1()
    3
    >>> c2()
    1
    >>> c2()
    2
    >>>

