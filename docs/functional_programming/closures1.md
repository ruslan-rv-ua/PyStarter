---
hide:
#  - navigation # Hide navigation
 - toc        # Hide table of contents
---


# Функції як результат функцій

Розглянемо наступний код:

```python
def outer():
    def inner():
        message = 'Hello!'
        print(message)
    inner()
```

Під час виконання функції `outer()` відбувається наступне:

1. Створюється об'єкт функції. 
2. Створюється локальна змінна `inner`, яка вказує на об'єкт функції.
3. Викликається функція, на яку вказує локальна змінна `inner`.
4. Функція `inner()` виконується, виводиться повідомлення.

Перевіримо:

    >>> outer()
    Hello!
    >>>

Зробимо трошки інакше:

```python
def outer():
    def inner():
        message = 'Hello!'
        print(message)
    return inner
```

Тепер під час виконання функції `outer()` відбувається наступне:

1. Створюється об'єкт функції. 
2. Створюється локальна змінна `inner`, яка вказує на об'єкт функції.
3. Функція `outer()` повертає локальну змінну `inner`, яка у свою чергу вказує на щойно створену функцію (об'єкт функції).

При виході з функції `outer()` усі її локальні змінні знищаться, включно зі змінною `inner`. 
Але якщо результат функції `outer` ми присвоємо іншій змінній, 
то об'єкт функції `inner()` залишиться в пам'яті:

    >>> f = outer()
    >>> f
    <function outer.<locals>.inner at 0x00000238B3C59080>
    >>> f.__name__
    'inner'
    >>>

Змінна `f` зараз вказує на об'єкт функції з ім'ям `inner`. 
І Python "знає" що ця функція є локальною по відношенню до функції `outer()`. 

І ми можемо виконати функцію, на яку вказує змінна `f`:

    >>> f()
    Hello!
    >>>

Зробимо "внутрішню" функцію з параметром:

```python
def outer():
    def inner(message):
        print(message)
    return inner
```

"Отримаємо" і викличемо функцію:

    >>> f = outer()
    >>> f('Python rocks!')
    Python rocks!
    >>>
