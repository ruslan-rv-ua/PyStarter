---
hide:
#  - navigation # Hide navigation
 - toc        # Hide table of contents
---

# Обробка винятків як керування ходом виконання програми

В статично типізованих мовах програмування компілятор контроює, 
чи реалізує клас, 
екземпляром якого є певний об'єкт, 
певний інтерфейс. 
При динамічній качиній типізації відповідальність за це лежить на програмісті. 

Як же можна з'ясувати, 
чи реалізує якийсь клас певний інтерфейс (наприклад, метод)? 
Існує два протилежних підходи до реалізації таких перевірок. 

Перший полягає у тому, що ми маємо можливість дійсно перевірити, 
чи реалізує клас певний інтерфейс, 
тобто чи має він певний атрибут. 
Зробити це можна за допомогою функції: 

	hasattr(object, name)
	
Функція повертає `True` якщо `object` має атрибут з ідентифікатором `name` і `False` в інших випадках.

Отже перевірка наявності інтерфейса і подальше його використання можуть виглядати так:

```python
p = Person('John Doe')
if hasattr(p, show_info):
	p.show_info()
else:
	print('No information')
```		

Інший спосіб полягає у тому, 
що ми не перевіряємо наявність певного інтерфейса, 
а одразу ж пробуємо його використовувати. 
Якщо інтерфейс не реалізовано, 
то, звісна річ, виникне виняткова ситуація. 
Але ми можемо перехопити виняток і обробити його так як нам потрібно! 

Повертаючись до попереднього прикладу: 

```python
p = Person('John Doe')
try:
	p.show_info()
except AttributeError:
	print('No information')
```		

Отже ми маємо два різних підходи (стилі) написання коду, вони навіть мають свої назви: 

* Look Before You Leap (LBYL, "Не спитавши броду не лізь у воду"). Стиль, який характеризується наявністю багатьох перевірок і умовних операторів. В контексті качиної типізації може означати перевірку наявності необхідних атрибутів за допомогою функції `hasattr`.
* Easier to Ask for Forgiveness than Permission (EAFP, "простіше попросити вибачення, ніж
дозволу").  Стиль, який характеризується наявністю блоків `try/except`. В контексті качиної
типізації — написання кода виходячи з припущення, що певний об'єкт реалізує необхідний інтерфейс, і обробка винятка `AttributeError` в іншому випадку.

`LBYL` і `EAFP` — це доволі загальні стилі написання кода на динамічних мовах програмування, 
які стосуються не тільки качиної типізації. Наприклад: 

* перевірка існування ключа у словнику (LBYL) або обробка винятка `KeyError` (EAFP)
* перевірка існування файла (LBYL) або обробка винятка `IOError` (EAFP)

Давайте напишемо рішення однієї і тої ж задачі використовуючи обидва стилі.

Задача: створити функцію `is_float(string)` яка перевіряє чи є рядок `string` представленням числа типу `float`.
Спочатку напишемо "звичайним" для нас на даний момент способом:

```python
def is_float(string):
    if string[0] == '-':
        string = string[1:]
    if string.isdigit():
        return True
    elif string.count('.') == 1 and string.replace('.', '').isdigit():
        return True
    else:
        return False
```
	
А тепер давайте вирішимо цю ж саму задачу дещо іншим способом:

```python
def is_float(string):
	try:
		float(string)
		return True
	except ValueError:
		return False
```

Тут ми не робимо ніяких перевірок даних. 
Ми просто перетворюємо символьний рядок на дійсне число, 
і якщо нам це не вдалося, 
то повертаємо відповідний результат.

Порівняйте другий варіант з першим по читабельності кода.

## `LBYL` vs `EAFP`

В Python деколи надають перевагу другому стилю — EAFP. 

* код простіше читається дякуючи відсутності зайвих перевірок;
* винятки в Python працюють відносно швидко;
* позбавляємось ризику виникнення стану перегонів у багатопоточних середовищах, що деколи 
трапляється при використанні підхода LBYL.

Однак користуватись винятками і їх обробкою для керуванням ходу виконання програми треба обережно 
і вдумливо, якщо це дійсно є виправданим. 
Необережне і невміле використання цього методу може призвести до серйозних помилок в реалізації алгоритму 
які, зазвичай, ще й важко виявити. 
Не зловживайте `EAFP` і по можливості уникайте. 

