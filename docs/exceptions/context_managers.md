---
hide:
#  - navigation # Hide navigation
 - toc        # Hide table of contents
---

> ***Менеджер контекста*** (context manager) — це спеціальний об'єкт, який використовується для автоматичного керування ресурсами. Він гарантує, що ресурси будуть правильно ініціалізовані, використані та звільнені, навіть якщо виникають помилки.

Менеджери контекста використовуються для збереження і відновлення глобального стану, 
блокування і розблокування ресурсів, 
автоматичного закрыття файлів та інше. 

Якщо маємо дві пов'язані операції, 
які хочемо виконати у парі 
помістивши між ними блок кода, 
то менеджери контекста дозволяють зробити саме це. 

Приклад: треба записати у файл дані. Під час цього можуть виникнути різні помилки. Але нам треба гарантовано закрити файл. 

```python
file = open('some_file.txt', 'w')
try:
	file.write('Hello!')
finally:
	file.close()
```		

Тепер реалізуємо це за допомогою менеджера контекста:

```python
with open('some_file', 'w') as opened_file:
	opened_file.write('Hello!')
```

Синтаксис інструкції `with ... as` виглядає так: 

	with <вираз> as <змінна>:
		<блок коду>
		
Частина `as ...` є необов'язковою. 
 
Якщо в інструкції `with ... as` було декілька виразів, 
то це еквівалентно декільком вкладеним інструкціям. 
Наприклад: 

	with A() as a, B() as b:
		# some code

еквівалентно наступному:

	with A() as a:
		with B() as b:
			# some code		

Розглянемо як можна створити власний менеджер контекста. 

## Контекст-менеджер як клас

Щоб об'єкт став менеджером контекста він має реалізовувати два спеціальних метода:

- `__enter__()`
- `__exit__()`

Нагадаємо собі ще раз інструкцію `with`:

	with <вираз> as <змінна>:
		<блок коду>
	
При виконанні даного блока відбувається наступне: 

1. Виконується вираз в інструкції `with ... as`.
1. Завантажується спеціальний метод `__exit__` для подальшого використання. 
1. Виконується спеціальний метод `__enter__`. Якщо інструкція `with` включає в себе `as`, то значення,  яке повертається методом `__enter__` пов'язується зі вказаною змінною.
1. Виконується блок коду.
1. Викликається метод `__exit__`, незалежно чи виконався блок коду чи під час його виконання сталась виняткова ситуація. 

Метод `__enter__()` має повертати ресурс, над яким виконуються дії в рамках даного контекста. 

У методі `__exit__()` можна обробити виняткові ситуації, які виникли під час виконання блока коду. Йому передаються три параметри: 

- 'exception_class' — клас винятка
- 'exception_value' — екземпляр винятка
- 'traceback' — інформація про виняток

Якщо під час виконання блока жодного винятка не було піднято, усім цим параметрам передається значення `None`. 

Якщо метод `__exit__()` повертає `True` — вважається, 
що винятки оброблено у цьому методі і нагору вони не піднімаються. 

Давайте спробуємо створити власний контекст-менеджер. 

Припустимо нам треба виконати певні дії 
помінявши перед цим поточну робочу директорію нашої програми у файловій системі, 
а потім встановити поточну директорію такою, як була раніше. 
Нам знадобляться дві функції з модуля `os`: 

- `os.chdir()` — встановлює поточну директорію
- `os.getcwd()` — повертає поточну директорію

Наш менеджер контекста може виглядати так: 

```python
import os

class cd:
	def __init__(self, path):
		self.path = path
	def __enter__(self):
		self.old_path = os.getcwd()
		os.chdir(self.path)
	def __exit__(self, c, e, t):
		os.chdir(self.old_path)
```

Спробуємо скористатись щойно створеним менеджером контекста (у вас результат буде іншим):

	>>> print(getcwd())
	c:\\dev\with
	>>> with cd("/"):
	...     print(getcwd())
	...
	c:\
	>>> print(getcwd())
	c:\\dev\with
	>>>

## Додаткові матеріали

1. [Документація Python: інструкція `with`](https://docs.python.org/3/reference/compound_stmts.html#with)
