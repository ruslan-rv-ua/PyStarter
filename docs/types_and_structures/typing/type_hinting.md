---
hide:
#  - navigation # Hide navigation
 - toc        # Hide table of contents
---

# Підказки типів в Python



<!-- 

https://dagster.io/blog/python-type-hinting
https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html
https://habr.com/ru/articles/415829/
 -->


Python — мова з динамічною типізацією, що дозволяє нам досить вільно оперувати змінними різних типів. 
Однак під час написання коду ми так чи інакше припускаємо, 
змінні яких типів будуть використовуватися, це може бути спричинено обмеженням алгоритму або бізнес-логіки. 
І для коректної роботи програми нам важливо якомога раніше знайти помилки, пов'язані з передачею даних невірного типу.

Зберігаючи ідею динамічної качиної типізації, 
Python, починаючи з версії 3.6, підтримує анотації типів змінних, полів класу, аргументів і значень функцій, що повертаються.

Анотації типів просто зчитуються інтерпретатором Python і жодним чином більше не обробляються.  

Чому варто використовувати підказки типів?

- ***Покращена читабельність коду***: Підказки типів діють як форма документації, яка допомагає розробникам зрозуміти типи аргументів, які очікує функція, і те, що вона повертає. Така наочність робить код більш читабельним і легшим для розуміння.
- ***Виявлення помилок***: Для статичного аналізу коду Python можна використовувати такі інструменти, як `pyright` та `mypy`. Вони перевіряють узгодженість типів у вашому коді на основі підказок типів і попереджають вас про помилки, пов'язані з типами, ще до виконання. 
- ***Краща підтримка IDE***: Багато інтегрованих середовищ розробки (IDE) та лінтерів можуть використовувати підказки типів для кращого автодоповнення коду, перевірки помилок та рефакторингу.
- ***Спрощує роботу з великими проектами***: У великих проектах з декількома розробниками підказки типів можуть бути дуже корисними для розуміння структури даних у початковому коді. Для невеликих або простих скриптів підказки типів можуть виявитись надмірними і потенційно ускладнити код, який має бути простим і зрозумілим.

У вбудованому модулі `typing` міститься кілька функцій і класів, які використовуються для створення підказок типів.

Далі дуже коротко, у вигляді "шпаргалки", розглянуто основні прийоми використання підказок типів.

### Змінні

    age: int = 1 # Технічно надлишково, оскільки програмні аналізатори самі можуть визначити тип змінної.
    a: int # вказуємо лише тип
    x: float = 1.0
    done: bool = True
    name: str = "test"
    data: bytes = b"test"

Для колекцій в Python 3.9+ тип елемента колекції вказується у квадратних дужках:

    numbers: list[int] = [1]
    numbers: set[int] = {6, 7}

Для відображень вказуємо тип ключа і відповідного значення:

    v: dict[str, float] = {"field": 2.0}  # Python 3.9+

Для кортежів фіксованої довжини перераховуємо типи усіх елементів:

    x: tuple[int, str, float] = (3, "yes", 7.5)  # Python 3.9+

Кортежі невизначеної довжини — додаємо `ellipsis`:

    x: tuple[int, ...] = (1, 2, 3)  # Python 3.9+

Для Python 3.8 і раніше тип колекції імпортується з модуля `typing`, вказуємо з великої букви:

    from typing import List, Set, Dict, Tuple
    x: List[int] = [1]
    x: Set[int] = {6, 7}
    x: Dict[str, float] = {"field": 2.0}
    x: Tuple[int, str, float] = (3, "yes", 7.5)
    x: Tuple[int, ...] = (1, 2, 3)



### Функції

У функціях можна вказувати тип параметрів і значення, яке функція повертає:

```python
def rectangle_area(length: float, width: float) -> float:
    return length * width

def sum_elements(numbers: list[int]) -> int:
    return sum(numbers)
```


### Union

Підказка типу `Union` використовується, щоб вказати, що змінна може бути одного з декількох типів. 
Наприклад, якщо змінна може бути як `str`, так і `int`:

```python
from typing import Union

def process(data: Union[str, int]) -> None:
    ...

# Python 3.10+
x: list[int | str] = [3, 5, "test", "fun"]
```

### Optional

Підказка типу `Optional` використовується, щоб вказати, що змінна може бути як певного типу, так і `None`.

```python
from typing import Optional

def find_student(student_id: int) -> Optional[dict[str, str]]:
    # якщо знайшли студента, повертаэмо словник з даними
    # інакше повертаємо None
    ...
```

`Optional[X]` — це те саме, що і `X | None` або `Union[X, None]`.



### Класи

В Python можна визначати власні типи за допомогою класів, 
що є фундаментальним механізмом для створення кастомних типів. 
Ви можете використовувати ці класи у підказках типів так само, як і вбудовані типи. 

```python
class Student:
    def __init__(self, name: str, age: int):
        self.name = name
        self.age = age

def print_student_details(student: Student) -> None:
    print(student.name, student.age)
```

Клас `Type` з модуля `typing` використовується для вказівки, що змінна буде класом, а не екземпляром класу. 

```python
from typing import Type

def create_student(cls: Type[Student], name: str, age: int) -> Student:
    return cls(name, age)
```


### NewType

`NewType` використовується для створення відмінних типів. 
Це корисно, коли ви хочете розрізнити два типи, які інакше були б однаковими.

Скажімо, ви маєте справу з ідентифікаторами студентів та ідентифікаторами курсів у вашій програмі, і ви хочете переконатися, що не переплутали їх. 
Обидва типи представлені як символьні рядки, тому ви можете використовувати NewType для створення двох різних типів:

```python
from typing import NewType

StudentID = NewType('StudentID', str)
CourseID = NewType('CourseID', str)

def get_student(student_id: StudentID) -> None:
    ...

def enroll_in_course(student_id: StudentID, course_id: CourseID) -> None:
    ...
```

Незважаючи на те, що `StudentID` та `CourseID` є символьними рядками, 
вони вважаються різними типами і не можуть використовуватися взаємозамінно. 
Однак пам'ятайте, що ця перевірка виконується не під час виконання, 
а під час статичної перевірки типів за допомогою спеціалізованих інструментів.


<!-- #### Дженеріки -->

## Статичні аналізатори типів

Тайпчекери (type checkers) — це інструменти, які перевіряють правильність типів даних у програмі за допомогою анотацій типів. Вони допомагають виявити потенційні помилки, пов'язані з неправильним використанням типів даних, що може призвести до непередбачуваної поведінки програми або помилок у виконанні.

Наприклад, якщо функція приймає на вхід число, але отримує рядок, це може призвести до помилки. Тайпчекери допомагають виявити такі помилки на етапі розробки, що дозволяє уникнути їх у продакшені.

Деякі з популярних тайпчекерів для Python:

- [**mypy**](https://mypy.readthedocs.io/en/stable/): Це один з найпоширеніших тайпчекерів Python, який перевіряє типи за допомогою анотацій типів (PEP 484) та надає розширену функціональність, таку як перевірка необов'язкових аргументів та підтримка декораторів для контролю типів.
- [**Pyright**](https://microsoft.github.io/pyright/#/): Реалізація тайпчекера для Python, розроблена на TypeScript, яка надає швидку перевірку типів та інтеграцію з редакторами, такими як Visual Studio Code.
- [**Pyre**](https://pyre-check.org): Це тайпчекер, який розробляється в Facebook і використовує статичний аналіз для визначення типів та виявлення помилок у програмах Python.
- [**Pytype**](https://google.github.io/pytype/): Інструмент для статичного аналізу та перевірки типів, розроблений у Google. Він аналізує код, щоб знайти помилки типів та надає рекомендації щодо їх виправлення.

Тайпчекери допомагають робити код Python більш надійним і підтримуваним шляхом забезпечення перевірки типів на етапі розробки.

Приклад. Наступний код збережемо у файлі `main.py`: 

```python
n = input('Введіть ціле число: ')
print(f"{n} у квадраті дорівнює {n*n}")
```

Тепер у теці де міститься файл `main.py` виконаємо:

    mypy main.py

І отримаємо звіт, одна помилка:

    main.py:2: error: Unsupported operand types for * ("str" and "str")  [operator]
    Found 1 error in 1 file (checked 1 source file)


## Додаткові матеріали

- [Документація: typing — Support for type hints](https://docs.python.org/3/library/typing.html)
<!-- 
- [Документація: PEP 3107 – Function Annotations](https://peps.python.org/pep-3107/)
- [Документація: PEP 484 – Type Hints](https://peps.python.org/pep-0484/)
- [Документація: PEP 526 – Syntax for Variable Annotations](https://peps.python.org/pep-0526/) 
-->
- [MyPy: Type hints cheat sheet](https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html)

