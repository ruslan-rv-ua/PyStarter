---
hide:
#  - navigation # Hide navigation
 - toc        # Hide table of contents
---

# Типи даних в Python

<!-- Усі типи даних в Python можна поділити на:

- ***Змінюваний (Mutable)*** — стан об'єкта може змінюватись після створення об'єкта;
- ***Незмінюваний (Immutable)*** — стан об'єкта не може змінюватись після створення об'єкта.
-->

<!-- ### Примітивні типи даних

- **Числа:**
    - Цілі числа: `int`
    - Числа з плаваючою комою: `float`
    - Комплексні числа: `complex`
- **Інші:**
    - Логічні значення: `bool`
    - Рядки: `str`
    - None (вказівка на відсутність певного значення): `NoneType` -->

По своїй сутності типи даних в Python можна розглядати як:

- ***Число (Number)*** — незмінювана величина, що підтримує числові операції;
- ***Контейнер*** — об'єкти містять у собі посилання на інші об'єкти;
- ***Послідовність (Sequence)*** — кінцевий упорядкований контейнер об'єктів, індексованих невід'ємними числами;
- ***Відображення (Mapping)*** — кінцевий контейнер об'єктів, індексованих довільними індексами;
- ***Викликане (Callable)*** — типи, до яких можна застосовувати операцію виклику функції;
- ***Ітерабельний (Iterable)*** — об'єкт, здатний повертати свої елементи один за одним;
- ***Дескриптор (Descriptor)*** — об'єкт, призначений для контролю доступу до атрибутів

та інші.

У свою чергу, наприклад, послідовності можна розділяти на:

- ***Гомогенні*** — послідовності, у яких всі елементи мають однаковий тип даних (`str, bytes, bytearray, memoryview, array.array`).
- ***Гетерогенні*** — послідовності, у яких елементи можуть мати різні типи даних (`list, tuple, collections.deque`).
- ***Мутабельні*** — `list, bytearray, array.array, collections.deque, memoryview`.
- ***Немутабельні*** — `tuple, str, bytes`.

В Python можна зробити так, щоб ваші класи відповідали певній сутності. 
Для цього клас має реалізувати відповідний протокол.

> ***Протокол*** (в контексті) — набір методів, який має реалізовувати клас щоб відповідати певним сутностям.

Наприклад щоб створити немутабельну послідовність клас має реалізувати методи `__len__` і `__getitem__`. 
Протокол мутабельної послідовності потребує того ж, плюс `__setitem__` і `__delitem__`. 
І, якщо ви бажаєте, щоб ваші об'єкти можна було перебирати ітераціями, ви маєте визначити `__iter__`, який повертає ітератор. 

Ще приклад. Створимо клас, який буде представляти собою контейнер парних цілих чисел. 
І реалізуємо можливість перевіряти чи є число парним за допомогою оператора `in`:

```python
class EvenNumbers:
    def __contains__(self, item):
        return isinstance(item, int) and item % 2 == 0
    
even_numbers = EvenNumbers()
```

Спробуємо:

    >>> 2 in even_numbers
    True
    >>> '2' in even_numbers
    False
    >>> 0 in even_numbers
    True
    >>> 1 in even_numbers
    False
    >>> -2 in even_numbers
    True
    >>>


### Колекції

> Колекція в Python — це програмний об'єкт (контейнер), який використовується для зберігання набору значень одного або різних типів. 
Ці значення можуть будь-якими типами даних, доступними в Python.

Розглянемо основні магічні методи, які використовують при реалізації колекцій:

#### `__getitem__(self, key)`

Визначає поведінку при доступі до елемента використовуючи наступний синтаксис: 

	self[key]`
	
Стосується протоколу мутабельних і протоколу немутабельних контейнерів. 

Для послідовностей `key` має бути цілим або зрізанням. При цьому в методі може бути реалізована інтерпретація від'ємних індексів. 

Метод має піднімати відповідний виняток: 

- `TypeError` — коли тип ключа не підтримується.
- `KeyError` — коли ключу не відповідає жодне значення у відображеннях.
- `IndexError` — якщо ключ виходить за межі ключей послідовності (у тому числі після інтерпретації від'ємних значень).

Цикл `for in` для правильного визначення кінця послідовності очікує, що для недопустимих індексів піднімається виняток `IndexError`.

#### `__len__(self)`

Повертає кількість елементів у контейнері. 
Частина протоколів для мутабельних та немутабельних колекцій. 

#### `__setitem__(self, key, value)`

Визначає поведінку при присвоєнні значення елементу при використанні синтаксису:

	self[key] = value
	
Частина протокола мутабельних колекцій. Має піднімати `KeyError` і `TypeError` у відповідних випадках.

#### `__delitem__(self, key)`

Визначає поведінку при видаленні елемента. 
Частина протокола для мутабельних колекцій. 
Має піднімати відповідний виняток, якщо ключ некоректний.

#### `__iter__(self)`

Повертає ітератор для контейнера.

#### `__reversed__(self)`

Визначає поведінку для вбудованої функції `reversed()`. 
Має повернути "зворотню" версію послідовності. 
Реалізується для послідовностей.

#### `__contains__(self, item)`

Реалізує перевірку належності елемента при використанні синтаксиса:
	
	in/not in
	
Метод не є частиною протокола послідовності, оскільки Python може самостійно виконувати пошук елемента "перебираючи" всю послідовність.

#### Collections and their exceptions:

|           |    List    |    Set     |    Dict    |
|-----------|------------|------------|------------|
| getitem() | IndexError |            |  KeyError  |
| pop()     | IndexError |  KeyError  |  KeyError  |
| remove()  | ValueError |  KeyError  |            |
| index()   | ValueError |            |            |


### Ітерабельні типи даних

Пригадаємо цикл `for ... in`. 
Давайте за допомогою цього цикла переберемо усі елементи списка: 

	>>> for i in [1,3,5,7]: print(i)
	...
	1
	3
	5
	7
	>>>
	
Зі списком усе зрозуміло: 
при черговому проході, або ж іншими словами — при кожній ітерації, 
ми отримуємо один черговий елемент списка (контейнера). 

Тепер спробуємо так: 

	>>> for i in range(4): print(i)
	...
	0
	1
	2
	3
	>>>
	
Результат для нас вже очікуваний. 
Але `range` не є контейнером, 
він не містить у собі чисел які ми перебираємо циклом! 

А ще, як нам вже відомо, 
за допомогою цикла `for` можна "пройтись" по символьним рядкам, словникам, навіть текстовим файлам. 
Тобто одна інструкція `for...in` виконує над об'єктами різних типів дуже схожі дії, 
а саме "перебирає" по одному значенню вміст цього об'єкта. 

> ***Ітерабельний об'єкт*** (в оригінальній термінології — іменник *iterable*) — це об'єкт, 
який може повертати значення по одному за раз. 

А давайте подивимось довідку до функції `sum()`:

    >>> help(sum)
    Help on built-in function sum in module builtins:

    sum(iterable, /, start=0)
        Return the sum of a 'start' value (default: 0) plus an iterable of numbers

        When the iterable is empty, return the start value.
        This function is intended specifically for use with numeric values and may
        reject non-numeric types.

    >>>

Саме цікаве зараз для нас наступне:

    sum(iterable, /, start=0)
        Return the sum of a 'start' value (default: 0) plus an iterable of numbers

Першим параметром функції може бути ***ітерабельний об'єкт чисел***. 

А чи є тип даних `dict` ітерабельним? Так, тому що ми можемо проітеруватись по словнику циклом `for`. 
І якщо ключами словника будуть числа, то ми можемо дізнатись суму всіх ключів словника:

    >>> sum({11:1, 22:2, 44:'hello'})
    77
    >>>

Так само і конструктор класа `list` приймає ітерабельний об'єкт:

    >>> list({11:1, 22:2, 44:'hello'})
    [11, 22, 44]
    >>> list(range(1, 10, 2))
    [1, 3, 5, 7, 9]
    >>> list('UFO')
    ['U', 'F', 'O']
    >>>

Щоб тип даних став ітерабельним він повинен реалізувати спеціальний метод `__iter__()`. 
Цей метод має повернути ***ітератор*** — об'єкт, за допомогою якого і здійснюється ітерування, 
тобто перебір елементів ітерабельного об'єкта по одному.


### Callable

У Python термін "callable" (іменник) використовується для опису об'єктів, які можна викликати як функції. 
Такі об'єкти повинні реалізувати метод `__call__()`.

```python
class Multiplier:
    def __init__(self, factor):
        self.factor = factor

    def __call__(self, /, x):
        return x * self.factor
    
x2 = Multiplier(2)
x3 = Multiplier(3)
```

Тепер екземпляри класа `Multiplier` можна використовувати як функції:

    >>> x2(5)
    10
    >>> x3(5)
    15
    >>>

В Python є вбудована функція `callable()`, яка приймає об'єкт в якості аргументу і повертає `True`, 
якщо об'єкт може бути викликаним як функція, і `False` в іншому випадку.

    >>> callable(x2)
    True
    >>> callable(Multiplier)
    True
    >>> callable(list)
    True
    >>>

# Додаткові матеріали

- [Документація: модуль `collections.abc` — абстрактні класи колекцій](https://docs.python.org/3/library/collections.abc.html#collections.abc.Container)




















