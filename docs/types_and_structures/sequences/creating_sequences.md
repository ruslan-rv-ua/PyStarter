---
hide:
#  - navigation # Hide navigation
 - toc        # Hide table of contents
---

# Створення послідовностей

Щоб об'єкт став послідовністю він має реалізувати два методи:

- `__len__` — повертає кількість елементів в послідовності.
- `__getitem__` — повертає елемент послідовності або список з елементів послідовності. 

Метод `__getitem__()` автоматично викликається у об'єкта `obj` кожного разу коли Python зустрічає наступну конструкцію:

    obj[...]

Якщо у квадратних дужках вказано ціле число, то для послідовностей це є операцією отримання елемента по його індексу. У такому разі функції `__getitem__()` передається вказане ціле число. 
Зауважимо що індексація завжди починається зі значення `0`.

Але якщо у квадратних дужках міститься символ двокрапки, тоді функції `__getitem__()` передається 
об'єкт, який представляє зрізання.

Функція має піднімати `IndexError` якщо операцію неможливо виконати. 
Наприклад у випадках коли вказаний індекс елемента меньше нуля або більше ніж довжина послідовності.


### Тип даних `slice`

У Python зрізання представлені вбудованим класом `slice`. 

Об'єкт `slice` містить три опційних параметри: `start`, `stop`, та `step`, які вказують початковий індекс, кінцевий індекс та крок відповідно. Ці параметри можуть бути передані як аргументи до функції `slice()` або використані безпосередньо при індексації.

Наприклад:

    >>> s=slice(1, -1)
    >>> s
    slice(1, -1, None)
    >>> s.start
    1
    >>> s.stop
    -1
    >>> s.step # None
    >>> [1,2,3,4,5][s]
    [2, 3, 4]
    >>>

`slice` має метод `indices()`, який дозволяє отримати конкретні індекси, які будуть використані при застосуванні цього зрізання для послідовності заданої довжини. 

    slice_object.indices(sequence_length)

де `sequence_length` — довжина послідовності, до якої застосовується зрізання.

Повертає кортеж з трьох значень: початкового індексу, кінцевого індексу та кроку, які відповідають зазначеному зрізу. 

    >>> s = slice(2, 8, 3)
    >>> s.indices(10)
    (2, 8, 3)
    >>> s.indices(100)
    (2, 8, 3)
    >>> s.indices(1)
    (1, 1, 3)
    >>> s.indices(0)
    (0, 0, 3)
    >>>


Цей метод можна використовувати для отримання еквівалентного зрізу з вказаної послідовності, що дозволяє уникнути виходу за межі послідовності. Наприклад:

    >>> s = slice(1, 5, 2)
    >>> s.indices(10)
    (1, 5, 2)
    >>>

Метод автоматично коригує значення початкового і кінцевого індексів, 
якщо вони виходять за межі довжини послідовності, 
і повертає кортеж із стандартизованими значеннями.

    >>> for index in range(10, 10, 1):
    ...     print(index)
    ...
    >>>
    >>>

#### Приклад: ступені двійки

Подивимось як можна створювати власні послідовності.

Реалізуємо послідовність цілих чисел — ступенів двійки. 
Для простоти тут обмежимось лише цілими невід'ємними індексами.

```python
class Power2:
    def __init__(self, length: int) -> None:
        # Ініціалізуємо об'єкт класу Power2 з вказаною довжиною
        self.length = length
    
    def __getitem__(self, index: int) -> int:
        # Перевіряємо, чи індекс ціле число
        if not isinstance(index, int):
            raise TypeError('index must be an integer')
        # Перевіряємо, чи індекс знаходиться в межах допустимого діапазону
        if not 0 <= index < self.length:
            raise IndexError('index out of range')
        # Повертаємо значення 2 в степені, яке відповідає індексу
        return 2**index
    
    def __len__(self) -> int:
        # Повертаємо довжину послідовності, яка визначена при ініціалізації
        return self.length
```

Отримуємо елементи послідовності по індексам:

    >>> p = Power2(10)
    >>> p[0]
    1
    >>> p[2]
    4
    >>> p[5]
    32
    >>> p[9]
    512
    >>> p[10]
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    File "e:\dev\PyStarter\docs\types_and_structures\sequences\demo\creating_sequences.py", line 8, in __getitem__
        raise IndexError('index out of range')
    IndexError: index out of range
    >>>

Оскільки елементи можна "перебирати" по індексам починаючи з 0, то у послідовностей з'являється ще одна дуже корисна властивість — вони ітерабельні:

    >>> for n in Power2(5):
    ...     print(n)
    ...
    1
    2
    4
    8
    16
    >>>

Отже можемо використовувати послідовності всюди, де очікується iterable:

    >>> list(Power2(10))
    [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]
    >>> sum(Power2(10))
    1023
    >>> sorted(Power2(10), reverse=True)
    [512, 256, 128, 64, 32, 16, 8, 4, 2, 1]
    >>> dict.fromkeys(Power2(5))
    {1: None, 2: None, 4: None, 8: None, 16: None}
    >>>

